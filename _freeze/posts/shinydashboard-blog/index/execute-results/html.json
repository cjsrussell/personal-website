{
  "hash": "2a6dd0c199076c78c98dc70c8fede33d",
  "result": {
    "markdown": "---\ntitle: \"Building a Simple Shiny Dashboard in R\"\nauthor: \"Connair Russell\"\ncategories: [Tutorial, Code, Shiny, R]\nimage: image.jpg\ndescription: \"Creating a data dashboard using the R package *shinydashboard*\"\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Show the code\"\nexecute: \n    eval: FALSE\n---\n\n\n## What is a Dashboard?\n\nA dashboard is a way to visually represent and explore your data. They are great for communicating findings, but they are also great for data exploration. With a Dashboard you can set a number of outputs (e.g. Plots, Tables) to automatically be displayed depending on your inputs. This means you can create one style of table or plot and generate those at the push of a button for all sorts of different variables.\n\n## Getting Started\n\nWe will be building our dashboard using shiny in R, specifically we will be using the [ShinyDashboard](https://rstudio.github.io/shinydashboard/) package and will be doing our work in RStudio.\n\nBefore we install any packages however, we will need to get our project set up. If you have not used projects before they are essentially self contained directories that keep all your scripts and files working together in one place.\n\nHere we want to create a \"Shiny Application\" project as follows:\n\n![](project.gif)\n\nI would always recommend using Git if you know how. renv is also valuable for this kind of project- it creates essentially a sandbox for your version of R packages. Which means that if you update the packages outside of the project, the ones in the project will stay as they were when you installed them (unless you update them inside your project using renv), so no surprise package changes that can break your entire app. It also allows you to export your package library versions too. You can find more about renv [here](https://rstudio.github.io/renv/index.html).\n\nThis should give you a project that looks something like this:\n\n![](newproj.jpg)\n\nThe only important file to worry about here is your `app.R` file. This is where the app is currently coded up!\n\nYou can see what this looks like by hitting Run App in RStudio. This should run the app:\n\n`note: if you want the app to run externally (e.g. in a browser instead ofthe RStudio viewer pane) select 'Run External' from the dropdown menu nect to the 'Run App' button`\n\n![](preview1.gif)\n\nHowever we are going to do things a slightly different way, using two files instead of one. We are going to have two files, one called `server.R` and one called `ui.R`. We will then move the section defining the ui into a new `ui.R` file, and keep the parts loading packages and defining the server info in a file we'll save as `server.R`.\n\nThe easiest way to do this is to open a new R Script file cut and paste in the ui scripts, save this as `ui.R`. Then we will save our old `app.R` file with the ui information removed as `server.R`. Then go ahead and delete `app.R`. We also want to delete the following from the `server.R`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run the application \nshinyApp(ui = ui, server = server)\n```\n:::\n\n\nYou should have two files that look like this:\n\n![server.R](server1.jpg)\n\n![ui.R](ui1.jpg)\n\nClick Run App again from within the `server.R` file just to make sure everything is still working!\n\nYou can think of `ui.R` as your front end. This is the file that determines what folks will see on your app, and where they can make inputs and change options. `server.ui` is the backend, taking the inputs from your ui and running the functions we want to run (e.g making plots).\n\nIt is perfectly acceptable to only use the app.R file with all this information in it. But that can become quite hard to handle with longer and more convoluted applications, so its cleaner (in my opinion) to use separate files.\n\n### Packages\n\nWe will be using ShinyDashboard so we need to install that, we will also be using syntax and ggplot from the Tidyverse so we will install those for now by running this in the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"shinydashboard\",\"tidyverse\"))\n```\n:::\n\n\nWe then need to load these up in `server.R` file so they are loaded with our app. We do this by adding the following to the top of `server.R`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n```\n:::\n\n\ntip: it is typically best practice to only install those sub packages of the Tidyverse that you will actually use, rather than the whole thing. But we will be a bit lazy here.\n\n## Creating Our Dashboard\n\n### First we need data!\n\nBefore we create a dashboard for our data we need some data that we will put in it! For illustration purposes we will simulate (crudely) a super simple dataset. This dataset will be from an imaginary study looking at mental health and exercise in four countries. This will give us a couple of categorical and a couple of numerical variables to put in our dashboard\n\nI have saved this as a .csv, so I will move that .csv file into my project folder and load it into my `server.R` file from there.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1993)\n\n#set our n at 2000\n\nn <- 2000\n\n#create demographic variables\n\n# Generate Age with a random sample of ages betweeen 18 and 70\n\nage <- sample(18:70, n, replace = TRUE)  \n\n# Generate sex with four categories with 45% 45% 5% and 5% respectively\n\nsex <- sex <- sample(c(\"Male\", \"Female\", \"Intersex\", \"Prefer not to say\"),\n              n, replace = TRUE, prob = c(0.45, 0.45, 0.05, 0.05))\n\n# Generate country by randomly sampling from four countries\n\ncountry <- sample(c(\"Bonsia\", \"Thailand\", \"Egypt\", \"Peru\"), n, replace = TRUE)\n\n# Generate four variables (two anxiety measures, two exercise) by randomly sampling from\n\ntrait_anxiety <- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\nstate_anxiety <- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\nsubj_ex <- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\nobj_ex <- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\n\n\n#put in dataframe\n\ndata <- data.frame(age = age,\n                   sex = sex,\n                   country = country,\n                   trait_anxiety = trait_anxiety,\n                   state_anxiety = state_anxiety,\n                   subjective_exercise = subj_ex,\n                   objective_exercise = obj_ex)\n\n\n#turn sex and country to factors:\n\ndata$sex <- factor(data$sex)\ndata$country <- factor(data$country)\n```\n:::\n\n\n### Creating a blank dashboard\n\nNow we have our data generated the first thing we need to do is make our empty dashboard, we can then populate this down the line. We make this by replacing the default `ui.R` script with the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- dashboardPage(\n  \n      dashboardHeader(),\n      \n      dashboardSidebar(),\n      \n      dashboardBody()\n)\n```\n:::\n\n\nThis dashboardPage includes the main elements of the dashboard: the heading, sidebar and body.\n\nWe also need to update our server.R script to load the right packages, load our new data, and delete the default stuff from our server function. The `server.R` file should now look like this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\ndata <- read.csv(\"data.csv\")\n\n\nserver <- function(input, output) {}\n```\n:::\n\n\nIf you hit Run App now you should see a blank dashboard with a sidebar and a main body:\n\n![](blank.jpg)\n\n### Title\n\nThe first simple thing we can do is add a title:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- dashboardPage(\n  \n      dashboardHeader(title = \"Example App\"),\n      \n      dashboardSidebar(),\n      \n      dashboardBody()\n)\n```\n:::\n\n\n![](title.jpg)\n\n### Settings box\n\nBefore we create any content from our data we need to create a settings box to decide what goes into it. The way different elements in ShinyDashboard work is by putting them in boxes, and then those boxes can be used to populate rows. For example, we can create a box for our settings, and a box for our plots aby updating the dashboardBody in `ui.R` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- dashboardPage(\n  \n      dashboardHeader(title = \"Example App\"),\n      \n      dashboardSidebar(),\n      \n      dashboardBody(\n        \n        #plot box (we will leave this empty for now)\n        \n        box(\n          width = 9, \n          title = \"Plots\"\n        ), \n        \n        #settings box\n        \n        box(\n          width = 3, #so our plot box is bigger\n          title = \"Settings\"\n        )\n      )\n)\n```\n:::\n\n\n`random tip: i would STRONGLY reccomend using rainbow parentheses in coding this kind of thing. It essentially makes corresponding open and close brackets mactch colours. Its enabled in Global Options -> Code -> Display. It is also good to use an RStudio theme with good parenthesis highlighting too!`\n\nYou can now see that we have empty plot and settings boxes.\n\n![](emptyboxes.jpg)\n\nTime to fill them!\n\nthe possibilities here are endless. You could add a single menu that allows users to select from predefined plots or tables. Or you could have an incredibly complex system that generates complicated plots on demand. We will do something in the middle. We will create a system that allows users to select what they want on the X and Y axes, and then generate the plots for them.\n\nSo we will add simple dropdown menus to select X-Axis and Y-Axis variables for our plots. \n\nHere is how we add the X-Axis option menu using selectInput in our `ui.R` file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#settings box\n        \nbox(\n  width = 3,\n  title = \"Settings\",\n  \n  selectInput(\n    \n    \n    #set the label for this input we will use internally\n    inputId = xaxis, \n    \n    \n    #the display name/title for this dropdown menu\n    label = \"Select X-Axis Variable\", \n    \n    \n     #here we populate the options for our dropdown menu, and give them better display labels\n    choices = list ( \"Trait Anxiety\" = \"trait_anxiety\",   \n                     \"State Anxiety\" = \"state_anxiety\", \n                     \"Exercise (subjective)\" = \"subj_ex\", \n                     \"Exercsie (objective)\" = \"obj_ex\", \n                     \"Age\" = \"age\", \n                     \"Sex\" = \"sex\"\n    )\n    )\n  )\n```\n:::\n\n\nWe can now repeat this for the Y-Axis\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#settings box\n        \nbox(\n  width = 3,\n  title = \"Settings\",\n  \n  selectInput(\n    inputId = \"xaxis\",\n    label = \"Select X-Axis Variable\", \n    choices = list ( \"Trait Anxiety\" = \"trait_anxiety\",   \n                     \"State Anxiety\" = \"state_anxiety\", \n                     \"Exercise (subjective)\" = \"subj_ex\", \n                     \"Exercsie (objective)\" = \"obj_ex\", \n                     \"Age\" = \"age\", \n                     \"Sex\" = \"sex\", \n                     \"Country\" = \"country\")\n    ), \n  \n  selectInput(\n    inputId = \"yaxis\",\n    label = \"Select Y-Axis Variable\", \n    choices = list ( \"Trait Anxiety\" = \"trait_anxiety\",   \n                     \"State Anxiety\" = \"state_anxiety\", \n                     \"Exercise (subjective)\" = \"subj_ex\", \n                     \"Exercsie (objective)\" = \"obj_ex\", \n                     \"Age\" = \"age\", \n                     \"Sex\" = \"sex\", \n                     \"Country\" = \"country\")\n    )          \n  \n  \n  )\n```\n:::\n\n\nIf you now hit Run App you should have something that looks like this, with 2 dropdown menus!\n\n![](dropdowns.jpg)\n\n### Making our plots\n\nNow we have the menu to select our variables we need to generate the relevant plots, and show them!\n\nThe UI part of this is quite simple. Just as we added input options to our settings box, we can add outputs to our plot box. We do this by just adding one line to our `ui.R` file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot box\n\nbox(\n  width = 9, \n  title = \"Plots\",\n  plotOutput(\"plot1\")\n)\n```\n:::\n\n\nThis will return \"plot1! in the plot box. However we have not yet defined this so we will do that now. This requires us to hop over to our `server.R` file.\n\nAs an example we will first imagine that we only have continuous variables as our options. This would make the task quite simple. We would just generate a plot where the data on the x and y axes are defined by our inputs. This is how we create generate outputs in `server.R`.\n\nWe take what we have already...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\ndata <- read.csv(\"data.csv\")\n\n\nserver <- function(input, output) {}\n```\n:::\n\n\nand add our output definition into \"server\". `output$plot1` creates the \"plot1\" we just added to our plot box in `ui.R`. renderPlot() renders the plot that is within it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\ndata <- read.csv(\"data.csv\")\n\n\nserver <- function(input, output) {\n  \noutput$plot1 <- renderPlot()\n  \n}\n```\n:::\n\n\nwe can now create a quick ggplot scatter plot to go in there. We use `input$xaxis` to tell ggplot to use the variable selected in the ui for xaxis as our xaxis, and `input$yaxis` to tell do the same for the y axis.\n\nWe use !!sym to use these string outputs from our inputs as column names.\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output) {\n  \n  output$plot1 <- renderPlot(\n    ggplot(data, aes(x = !!sym(input$xaxis), y = !!sym(input$yaxis))) +\n      geom_point()\n    )\n}\n```\n:::\n\n\nYou now have a working dashboard! Hit \"Run App\" and have a look.\n\n![](firstworking.jpg)\n\nWe could also quickly add a quick bit of flavor to our numerical plots by getting it to colour the plot by country (we will make this selectable later on!), and changing the theme. But that us it for aesthetic changes for this blog.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = !!sym(input$xaxis), y = !!sym(input$yaxis), color = country)) +\n  geom_point() +\n  theme_minimal()\n```\n:::\n\n\n\n\n![](withcol.jpg)\n\n\nAs we can see this plot works well for our numerical variables, but is less useful for our two categorical ones. So we are going to need different plots depending on our variables. This makes things a little more complicated. But fear not, it is easily achievable by making our output$plot1 call a function which tells it which plot to render, instead of rendering a plot directly.\n\n\nSo lets create a function that gives us different plots for different variable combinations. Specifically we will have 4 combinations:\n\nX-axis categorical + Y-axis categorical\nX-axis categorical + Y-axis numeric\nX-axis numeric + Y-axis categorical\nX-axis numeric + Y-axis numeric\n\nWe will solve this by creating a function that returns different plots for different combinations. Here is the empty function with the arguments(things we put into the function) we are going to need. We will put this function in our `server.R` file before the server function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotFunction <- function(data, xvar, yvar){}\n```\n:::\n\n\nWe now add a series of if else statements to do our different plots\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotFunction <- function(data, xvar, yvar) {\n  \n  #here we say that if xvar amd yvar are both factors (categorical), then run the plot code in the squiggly brakets\n  \n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    #plot script here\n    \n  }\n  \n}\n```\n:::\n\n\nOne way to plot two categorical variables is using a stacked bar chart, we will do that here as a somewhat hacky (it doesnt really use one variable as the y axis) example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotFunction <- function(data, xvar, yvar) {\n  \n#here we say that if xvar amd yvar are both factors (categorical), then run the plot code in the squiggly brackets\n  \n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    ggplot(data,\n           aes(x = xvar,\n               fill = yvar)) +\n      geom_bar(position = \"stack\")\n    \n    \n    #Here we specify that if they are not, use our original plot (with the variables replaced to match those in our function)\n    \n  } else {\n    ggplot(data, aes(x = xvar, y = xvar +\n                       geom_point()))\n  }\n  \n}\n```\n:::\n\n\nOk we now have a simple function that can give us some different plots. Before we go further we should test it. To do this we first have to tell our server to use this function. We do this by updating output$plot1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#here we specify that output plot1 (which is what we put in our box on our dashboard) should plot whatever comes out of the plotFunction function when we input xaxis (from our ui) as \"xvar\", and yaxis (from our ui) as \"yvar\"\n\noutput$plot1 <- renderPlot(plotFunction(\n  data = data,\n  xvar = !!!sym(input$xaxis),\n  yvar = !!sym(input$yaxis)\n))\n```\n:::\n\n\nSo. `server.R`should look something like this now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\n\ndata <- read.csv(\"data.csv\")\n\n#### Plot function ####\n\n\nplotFunction <- function(data, xvar, yvar) {\n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    ggplot(data,\n           aes(x = !!sym(xvar),\n               fill = !!sym(yvar))) +\n      geom_bar(position = \"stack\")\n    \n  } else {\n    ggplot(data, aes(\n      x = !!sym(xvar),\n      y = !!sym(yvar),\n      color = country\n    )) +\n      geom_point() +\n      theme_minimal()\n  }\n  \n}\n\n\n#### Server ####\n\n\nserver <- function(input, output) {\n  output$plot1 <- renderPlot(plotFunction(\n    data = data,\n    xvar = input$xaxis,\n    yvar = input$yaxis\n  ))\n}\n```\n:::\n\n\nGo ahead and test it out! It should look like this:\n\n![](categorical.jpg)\n\n![](numeric.jpg)\n\nWe can now go ahead and finish specifying our different plots. For plots where we have a categorical and a numerical variable we could use boxplots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = !!sym(xvar),\n                 y = !!sym(yvar),\n                 color = !!sym(xvar))) +\n  \n  geom_boxplot(position = \"dodge\",\n               scale = 0.75,\n               width = 0.12)\n```\n:::\n\n\n\nWe can now add this to our function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotFunction <- function(data, xvar, yvar) {\n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    ggplot(data,\n           aes(x = !!sym(xvar),\n               fill = !!sym(yvar))) +\n      geom_bar(position = \"stack\") +\n      theme_minimal()\n    \n#we update the else to be an else if, saying that if x is a factor and y is numeric then run this plot\n    \n    } else if (is.factor(data[[xvar]]) && is.numeric(data[[yvar]])) {\n      \n    ggplot(data, aes(x = !!sym(xvar),\n                 y = !!sym(yvar), \n                 color = !!sym(xvar))) +\n        geom_boxplot(position = \"dodge\",\n               scale = 0.75,\n               width = 0.12) +\n        theme_minimal()\n      \n# now we do that the other way around\n      \n      \n    } else if (is.factor(data[[yvar]]) && is.numeric(data[[xvar]])) {\n      \n      ggplot(data, aes(x = !!sym(yvar),\n                       y = !!sym(xvar), \n                       color = !!sym(yvar))) +\n        geom_boxplot(position = \"dodge\",\n                     scale = 0.75,\n                     width = 0.12) +\n        theme_minimal()\n      \n# we now just say if it was none of the above run our original scatter plot\n      \n    } else {\n    ggplot(data, aes(x = !!sym(xvar),\n                     y = !!sym(yvar),\n                     color = country)) +\n      geom_point() +\n      theme_minimal()\n  }\n  \n}\n```\n:::\n\n\n#### So there you have it. A working dashboard, albeit a simple one. Below here I will go over a couple of extra features, but what we have done above should be a pretty good start to start looking at your data.\n\n\n## The sidebar\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}