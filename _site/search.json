[
  {
    "objectID": "posts/website-blog/index.html",
    "href": "posts/website-blog/index.html",
    "title": "Recreating Hugo Academic in Quarto",
    "section": "",
    "text": "This is a post with code."
  },
  {
    "objectID": "posts/codebook-blog/index.html",
    "href": "posts/codebook-blog/index.html",
    "title": "Creating a Data Codebook in Quarto",
    "section": "",
    "text": "Codebooks (or data dictionaries) are the documentation for your data. At the very minimum they contain the definitions of your variables, and at best they include additional information about your data such as question text, response scales, and variable coding schemes.\nIn this brief guide I will go through how and why you might want to create a codebook, hopefully showing how simple it is. We will do this using Quarto in RStudio, allowing us to have both offline (PDF) and online versions of the same document. All of this can be done in VS Code or other platforms and the Quarto documentation has you covered there (see links below).\nFor simple datasets a single page document might be fine, but for more complex datasets with nontrivial coding schemes more clear documentation is helpful.\n\n\nIt’s very easy to wax lyrical about the importance of open data and its key role in improving psychological and other sciences hit by recent crises, and i’ll do that in the next section, but perhaps the biggest beneficiary of good documentation will be you!\nWhen we’re working on projects we are often so deep into what we’re doing that forgetting some important information is inconceivable, but in a few years you want to be able to understand your work just as well. Keeping clear documentation of exactly what you did to end up with the datafile you have allows you to jump right back in without the befuddlement of trying to interpret the variable names created by your former self.\nAnother great benefit is that it can help with consistency across datasets and projects. If you have a specific variable scheme for a measure you use frequently, keeping a codebook can help you stay consistent.\n\n\n\nOpen science is better science, well at the very least it is not worse science. Whether someone will ever actually look at your data is an open question but if they do you want them to be able to interpret what is going on. You never know, they might find something really cool. This is not a blog on open science or the benefits of data sharing, they have been written a million times by folks more knowledgable than me, but here are two of the key reasons, in my opinion, that having open data (and a codebook!) are good for science.\nIt’s transparent. If we are sharing some or other conclusion based on data it is only fair that people are able to scrutinise that conclusion. Without the ability to actually look at the data we are taking authors’ conclusions on faith, which given recent scandals in the sciences, is not as easy as it once was. It’s less about policing, and more about being able to stand up and say “hey, don’t take my word for it, here is the data”.\nHaving your data available makes it accessible to other scholars and members of the public who may want to build upon it. We all have our own worldviews, interests and skills and someone might have a take on your work you had never even considered. This can lead to innovation and possible collaboration. It also allows folks who may not have the luxury of funding systems that allow the collection of large and high quality data sets, yet again possibly fostering innovation and collaboration.\nScience is a collective effort, and open, interpretable data fosters this."
  },
  {
    "objectID": "posts/codebook-blog/index.html#what-is-a-codebook-and-why-do-i-need-one",
    "href": "posts/codebook-blog/index.html#what-is-a-codebook-and-why-do-i-need-one",
    "title": "Creating a Data Codebook in Quarto",
    "section": "",
    "text": "Codebooks (or data dictionaries) are the documentation for your data. At the very minimum they contain the definitions of your variables, and at best they include additional information about your data such as question text, response scales, and variable coding schemes.\nIn this brief guide I will go through how and why you might want to create a codebook, hopefully showing how simple it is. We will do this using Quarto in RStudio, allowing us to have both offline (PDF) and online versions of the same document. All of this can be done in VS Code or other platforms and the Quarto documentation has you covered there (see links below).\nFor simple datasets a single page document might be fine, but for more complex datasets with nontrivial coding schemes more clear documentation is helpful.\n\n\nIt’s very easy to wax lyrical about the importance of open data and its key role in improving psychological and other sciences hit by recent crises, and i’ll do that in the next section, but perhaps the biggest beneficiary of good documentation will be you!\nWhen we’re working on projects we are often so deep into what we’re doing that forgetting some important information is inconceivable, but in a few years you want to be able to understand your work just as well. Keeping clear documentation of exactly what you did to end up with the datafile you have allows you to jump right back in without the befuddlement of trying to interpret the variable names created by your former self.\nAnother great benefit is that it can help with consistency across datasets and projects. If you have a specific variable scheme for a measure you use frequently, keeping a codebook can help you stay consistent.\n\n\n\nOpen science is better science, well at the very least it is not worse science. Whether someone will ever actually look at your data is an open question but if they do you want them to be able to interpret what is going on. You never know, they might find something really cool. This is not a blog on open science or the benefits of data sharing, they have been written a million times by folks more knowledgable than me, but here are two of the key reasons, in my opinion, that having open data (and a codebook!) are good for science.\nIt’s transparent. If we are sharing some or other conclusion based on data it is only fair that people are able to scrutinise that conclusion. Without the ability to actually look at the data we are taking authors’ conclusions on faith, which given recent scandals in the sciences, is not as easy as it once was. It’s less about policing, and more about being able to stand up and say “hey, don’t take my word for it, here is the data”.\nHaving your data available makes it accessible to other scholars and members of the public who may want to build upon it. We all have our own worldviews, interests and skills and someone might have a take on your work you had never even considered. This can lead to innovation and possible collaboration. It also allows folks who may not have the luxury of funding systems that allow the collection of large and high quality data sets, yet again possibly fostering innovation and collaboration.\nScience is a collective effort, and open, interpretable data fosters this."
  },
  {
    "objectID": "posts/codebook-blog/index.html#making-a-codebook-in-quarto",
    "href": "posts/codebook-blog/index.html#making-a-codebook-in-quarto",
    "title": "Creating a Data Codebook in Quarto",
    "section": "Making a codebook in Quarto",
    "text": "Making a codebook in Quarto\n\nWhat is Quarto?\nQuarto is great. It was made by the folks over at Posit (who make RStudio) and provides a singe ecosystem for your coding notebooks, websites, presentations, along with books and other documents.\nInstalling it is super easy and an installation guide can be found here. I’ll be using RStudio for this example but all of this can also be done using other tools (i made my codebook for my current project in VS Code) and these are also covered in the above link.\n\n\nSetting up a Quarto book\nTo get started we will need to create a blank book project. If you have not used projects before they are a nice tidy way to keep related files collected together in their own directory.\nWe will use the Quarto Book format and to create one you go to:\nFile -&gt; New Project… -&gt; New Diectory -&gt; Quarto Book\nYou can then choose the folder name for your directory, and where you want it to be stored. If you use renv and/or git you can tick those options, but they’re not needed to make it work.\n\nThis will create your project and generate some files for you:\n_quarto.yml - this is the main settings and contents page for your codebook.\nindex.qmd - this and the other .qmd files are the different pages of your codebook\nreferences.bib is the bibliography file for any references you might want to include.\nWe already have everything we need to to make our book! We will make one quick change here and then you can now see what this looks like without any further input.\nin _quarto.yml we will update the format section to include word document, so it should look like this (without my comments):\n\nformat:\n  html:\n    theme: cosmo\n  pdf:\n    documentclass: scrreprt\n  docx:                          # this adds .docx output format\n   toc: true                     # this enables table of contents\n   number-sections: true         # this enables section numbering\n\nWe can now see what this Word document and a PDF would look like! You can do this by clicking the dropdown in RStudio:\n \nor by running the following in the terminal (not the R console, the other tab!). This will create a _book folder in your directory in which you can see PDF and a .docx file of your book:\n\nquarto render\n\nand we can preview the web version from the console, too:\n\nquarto preview\n\nYou can choose whether it previews the website version of our book in the RStudio viewer pane, or an external window (e.g. browser). To do this just click the cog icon:\n\n\nOk so we have now set up our blank book. We now need to decide what we’re going to fill it with!\n\n\nWhat’s going in our codebook?\nAt the very minimum it is typically recommended that a codebook should probably have some of the following information (i’ve chosen these specifically for psych style research), we will go through and make an example with all of these shortly:\n\n\n\n\n\n\n\nVariable name:\nthe name of the variable in your script/datafile\n\n\nVariable Label\na human readable description of the variable\n\n\nVariable definition\nWhat is the variable? Is it a response to a specific question? Is it an index scoring a number of items (e.g., a mean), if so how was this computed?\n\n\nVariable type\nIs this a numerical variable? categorical?\n\n\nUnits (if applicable)\nThe unit of measurement for the variable\n\n\nResponse options\n(if applicable)\nThe range of possible response options for the variable\n\n\nResponse coding\n(if applicable)\nHow response options were coded or scored.\n\n\nMissing data/ error codes\n(if applicable)\nSpecific responses used to code things such as missing data, errors etc.\n\n\n\nIt is also incredibly valuable to include information about the measures from which your variables are derived. We will do this in our example, too.\n\n\nBuilding our codebook\nLets imagine we are running a study on exercise and mental health and want to create a data dictionary for this. Our hypothetical dataset includes questionnaire questions, indices from these, and objective excersise measures. In the interests of open science we want to make the codebook as comprehensive as possible.\nThe first thing we want to do is decide how we are going to structure it. For this example we will have an overview page with a minimal codebook, along with more detailed pages for our different measures. We’ll create the more detailed version first and condense this into the minimal version at the end.\n\nLets create an example page!\nImagine we want to summarize one of our anxiety measures, say a questionnaire measure of Trait Anxiety. To create a page in our book for this we just need to create a new .qmd file.\n \nLets title it “Trait Anxiety”, and save it as “traitanx.qmd” in the directory of our project. You’ll end up with a blank document which we will start to populate.\nIf using a recent version of RStudio you will see that you can edit the documents in both “Visual” and “Source” modes. Both work fine, in source you write in markdown, where as the visual editor lets us do things like insert tables and citations using the GUI instead of writing the code. We’ll mainly use the visual editor for simplicity.\nUnderneath the info codechunk at the top of the page we will add some sections to describe our Trait Anxiety measure. In markdown you specify headers with # followed by a space then the header, and this is how you do it both in the visual and source editors. So to get the heading “Measure” we would type “## Measure”. ## is a level 2 heading, ### a level three heading and so on.\nWe will now add headers for the different elements we want to include in our codebook.\nHere is what that looks like in the visual editor:\n\n\nand source editor:\n\n\nWe can now fill in the information for these sections.\nUnder the Measure section we can add an overview of our measure, including a citation if we want. To add a citation you can click insert -&gt; Citation:\n\n\nThis will then give you the possible citations. These can be from a number of sources such as the references.bib file in your project diectory (you can get .bib files from exporting from most citation managers), or if like me you use Zotero you can access your library directly:\n \nWhatever citation you insert would then automatically be in the references.qmd page when it is rendered.\nAfter we have outlined the measure we can now move on to the Questions section. Here we can specify the questions asked in this particular measure. We can do this by inserting a table (this is horrible in Markdown so I’d use the visual editor for this). This is done by selecting Table -&gt; Insert Table at the top of the page.\nSo we should have something like this so far:\n\n\nWe can now move on to the next section response options. Here we could again use a table to show what response options were used for this question:\n\n\nIn the next part Response Coding, we can specify how we coded these response options, if anything was reverse coded, and even include our scripts for this coding. You can insert a code chunk via the insert menu in the gui, or with the relevant syntax. Here is an example including a chunk of R code with a hypothetical function to code the responses.\n\n\nNOTE: if you include a codeblock like this, be sure to include eval=FALSE, this makes sure that r wont try to run the code when you render your codebook\nWe can now move on to the Scoring section where again we can add a description and possible script for how this was done. For example:\n\n\nFinally we can create the outline of our variables from this measure. Again, I’d use a table for this:\n\nWe’ve finished our first page!\nIf you preview this (using the render button noted above) you should end up with a webpage version that looks a bit like this:\n\n   \nand a PDF page that looks like this:\n   \n\n\n\nAdding our page(s) to our book\nSo we now have a page for one of our measures. I’m going to duplicate this and pretend that we have done multiple other pages too. One for state anxiety, two for excersise (subjective and objective), and a page for our demographic measures.\nWe add these to our book through the file called _quarto.yaml. This should currently look like this:\n \nWe can update what pages are in our book by changing the “chapters” element like so:\n\nThis will create a book for us with each of the elements of “chapters” as, wait for it, chapters!\nTo render the book just go to the terminal at the bottom of RStudio and type\nquarto render\n\nYou now have the full book in .docx and PDF in the _book folder. But we’re not done yet! We will quickly make a quickfire codebook page, and then we will publish the codebook as an online book!\n\n\nBrief codebook\nIn addition to the individual pages which have all the detail, we can create a shorter quick reference codebook with just the variables. We will create a new Quarto file called codebook-quick.qmd to do this.\nTo make this easy to use we will split it into variables and individual questions. We will then just put in the variables from our various pages. As simple as that. For example, it could look like this:\n Add that to _quarto.yaml, render it again, and you’re good to go!\n\n\n\nPublishing your codebook online!\nWe now have our offline codebooks and the last things to do is get our version online.\nThis is incredibly easy, its as simple as typing\nquarto publish\nin the terminal… well sort of. You need to choose where you’re publishing it first. There are a number of options and guides for these here, but ill run you through publishing it on Quarto’s own platform for free.\nTo do that you type this into the terminal:\nquarto publish quarto-pub\nrunning this will ask you to set up a Quarto Pub account. You do this on their website here, and then come back to RStudio and simply follow the prompts in the terminal! Easy peasy.\n \n\nYou now have an offline and an online documentation for your data. I hope this was helpful :)"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Connair’s Blog",
    "section": "",
    "text": "Recreating Hugo Academic in Quarto\n\n\n1 min\n\n\n\nTutorial\n\n\nQuarto\n\n\n\nA guide on how I built this website by recreating the Hugo Academic website theme in Quarto\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a Data Codebook in Quarto\n\n\n21 min\n\n\n\nTutorial\n\n\nQuarto\n\n\nCode\n\n\nOpen Science\n\n\n\nA step by step guide on how to create a codebook for your dataset\n\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding a Simple Shiny Dashboard in R\n\n\n28 min\n\n\n\nTutorial\n\n\nCode\n\n\nShiny\n\n\nR\n\n\n\nCreating a data dashboard using the R package shinydashboard\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Connair J. S. Russell",
    "section": "",
    "text": "GitHub\n  \n  \n    \n     Twitter\n  \n  \n    \n     . Google Scholar\n  \n  \n    \n     Linkedin\n  \n\n  \n  \n\n\nI am currently a postdoc working as a Research Fellow at Queen’s University Belfast, on the core Explaining Atheism project.\nI am interested in the Cognitive Science of Religion, or more specifically, the Cognitive Science of Non-Religion. The Explaining Atheism project is investigating the major psychological and social factors influencing non-belief (e.g. Cognitive Biases, Religious Socialisation). We are examining this across cultures, and in particular, we look to use modern causal inference techniques to look at the causal pathways to non-belief (as best we can).\nPrior to joining the EA team i completed my PhD in 2022. Based at the Max Planck Institute for Human Development in Berlin, my PhD looked at cognitive biases in how we learn and generalise different kinds of information.\n\n\n\n\n\nCognitive Science of Religion\n\n\n\n\n\n\n\n\n PhD in Psychology, 2022\n\nMax Planck Institute for Human Development, & Freie Universität Berlin"
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Connair J. S. Russell",
    "section": "",
    "text": "I am currently a postdoc working as a Research Fellow at Queen’s University Belfast, on the core Explaining Atheism project.\nI am interested in the Cognitive Science of Religion, or more specifically, the Cognitive Science of Non-Religion. The Explaining Atheism project is investigating the major psychological and social factors influencing non-belief (e.g. Cognitive Biases, Religious Socialisation). We are examining this across cultures, and in particular, we look to use modern causal inference techniques to look at the causal pathways to non-belief (as best we can).\nPrior to joining the EA team i completed my PhD in 2022. Based at the Max Planck Institute for Human Development in Berlin, my PhD looked at cognitive biases in how we learn and generalise different kinds of information.\n\n\n\n\n\nCognitive Science of Religion\n\n\n\n\n\n\n\n\n PhD in Psychology, 2022\n\nMax Planck Institute for Human Development, & Freie Universität Berlin"
  },
  {
    "objectID": "posts/shinydashboard-blog/index.html",
    "href": "posts/shinydashboard-blog/index.html",
    "title": "Building a Simple Shiny Dashboard in R",
    "section": "",
    "text": "A dashboard is a way to visually represent and explore your data. They are great for communicating findings, but they are also great for data exploration. With a Dashboard you can set a number of outputs (e.g. Plots, Tables) to automatically be displayed depending on your inputs. This means you can create one style of table or plot and generate those at the push of a button for all sorts of different variables."
  },
  {
    "objectID": "posts/shinydashboard-blog/index.html#what-is-a-dashboard",
    "href": "posts/shinydashboard-blog/index.html#what-is-a-dashboard",
    "title": "Building a Simple Shiny Dashboard in R",
    "section": "",
    "text": "A dashboard is a way to visually represent and explore your data. They are great for communicating findings, but they are also great for data exploration. With a Dashboard you can set a number of outputs (e.g. Plots, Tables) to automatically be displayed depending on your inputs. This means you can create one style of table or plot and generate those at the push of a button for all sorts of different variables."
  },
  {
    "objectID": "posts/shinydashboard-blog/index.html#getting-started",
    "href": "posts/shinydashboard-blog/index.html#getting-started",
    "title": "Building a Simple Shiny Dashboard in R",
    "section": "Getting Started",
    "text": "Getting Started\nWe will be building our dashboard using shiny in R, specifically we will be using the ShinyDashboard package and will be doing our work in RStudio.\nBefore we install any packages however, we will need to get our project set up. If you have not used projects before they are essentially self contained directories that keep all your scripts and files working together in one place.\nHere we want to create a “Shiny Application” project as follows:\n\nI would always recommend using Git if you know how. renv is also valuable for this kind of project- it creates essentially a sandbox for your version of R packages. Which means that if you update the packages outside of the project, the ones in the project will stay as they were when you installed them (unless you update them inside your project using renv), so no surprise package changes that can break your entire app. It also allows you to export your package library versions too. You can find more about renv here.\nThis should give you a project that looks something like this:\n\nThe only important file to worry about here is your app.R file. This is where the app is currently coded up!\nYou can see what this looks like by hitting Run App in RStudio. This should run the app:\nnote: if you want the app to run externally (e.g. in a browser instead ofthe RStudio viewer pane) select 'Run External' from the dropdown menu nect to the 'Run App' button\n\nHowever we are going to do things a slightly different way, using two files instead of one. We are going to have two files, one called server.R and one called ui.R. We will then move the section defining the ui into a new ui.R file, and keep the parts loading packages and defining the server info in a file we’ll save as server.R.\nThe easiest way to do this is to open a new R Script file cut and paste in the ui scripts, save this as ui.R. Then we will save our old app.R file with the ui information removed as server.R. Then go ahead and delete app.R. We also want to delete the following from the server.R:\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\nYou should have two files that look like this:\n\n\n\nserver.R\n\n\n\n\n\nui.R\n\n\nClick Run App again from within the server.R file just to make sure everything is still working!\nYou can think of ui.R as your front end. This is the file that determines what folks will see on your app, and where they can make inputs and change options. server.ui is the backend, taking the inputs from your ui and running the functions we want to run (e.g making plots).\nIt is perfectly acceptable to only use the app.R file with all this information in it. But that can become quite hard to handle with longer and more convoluted applications, so its cleaner (in my opinion) to use separate files.\n\nPackages\nWe will be using ShinyDashboard so we need to install that, we will also be using syntax and ggplot from the Tidyverse so we will install those for now by running this in the console:\n\ninstall.packages(c(\"shinydashboard\",\"tidyverse\"))\n\nWe then need to load these up in server.R file so they are loaded with our app. We do this by adding the following to the top of server.R:\n\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\ntip: it is typically best practice to only install those sub packages of the Tidyverse that you will actually use, rather than the whole thing. But we will be a bit lazy here."
  },
  {
    "objectID": "posts/shinydashboard-blog/index.html#creating-our-dashboard",
    "href": "posts/shinydashboard-blog/index.html#creating-our-dashboard",
    "title": "Building a Simple Shiny Dashboard in R",
    "section": "Creating Our Dashboard",
    "text": "Creating Our Dashboard\n\nFirst we need data!\nBefore we create a dashboard for our data we need some data that we will put in it! For illustration purposes we will simulate (crudely) a super simple dataset. This dataset will be from an imaginary study looking at mental health and exercise in four countries. This will give us a couple of categorical and a couple of numerical variables to put in our dashboard\nI have saved this as a .csv, so I will move that .csv file into my project folder and load it into my server.R file from there.\n\nset.seed(1993)\n\n#set our n at 2000\n\nn &lt;- 2000\n\n#create demographic variables\n\n# Generate Age with a random sample of ages betweeen 18 and 70\n\nage &lt;- sample(18:70, n, replace = TRUE)  \n\n# Generate sex with four categories with 45% 45% 5% and 5% respectively\n\nsex &lt;- sex &lt;- sample(c(\"Male\", \"Female\", \"Intersex\", \"Prefer not to say\"),\n              n, replace = TRUE, prob = c(0.45, 0.45, 0.05, 0.05))\n\n# Generate country by randomly sampling from four countries\n\ncountry &lt;- sample(c(\"Bonsia\", \"Thailand\", \"Egypt\", \"Peru\"), n, replace = TRUE)\n\n# Generate four variables (two anxiety measures, two exercise) by randomly sampling from\n\ntrait_anxiety &lt;- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\nstate_anxiety &lt;- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\nsubj_ex &lt;- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\nobj_ex &lt;- pmin(7, pmax(1, rnorm(n, mean = 3.5, sd = 1)))\n\n\n#put in dataframe\n\ndata &lt;- data.frame(age = age,\n                   sex = sex,\n                   country = country,\n                   trait_anxiety = trait_anxiety,\n                   state_anxiety = state_anxiety,\n                   subjective_exercise = subj_ex,\n                   objective_exercise = obj_ex)\n\n\n#turn sex and country to factors:\n\ndata$sex &lt;- factor(data$sex)\ndata$country &lt;- factor(data$country)\n\n\n\nCreating a blank dashboard\nNow we have our data generated the first thing we need to do is make our empty dashboard, we can then populate this down the line. We make this by replacing the default ui.R script with the following:\n\nui &lt;- dashboardPage(\n  \n      dashboardHeader(),\n      \n      dashboardSidebar(),\n      \n      dashboardBody()\n)\n\nThis dashboardPage includes the main elements of the dashboard: the heading, sidebar and body.\nWe also need to update our server.R script to load the right packages, load our new data, and delete the default stuff from our server function. The server.R file should now look like this.\n\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\ndata &lt;- read.csv(\"data.csv\")\n\n\nserver &lt;- function(input, output) {}\n\nIf you hit Run App now you should see a blank dashboard with a sidebar and a main body:\n\n\n\nTitle\nThe first simple thing we can do is add a title:\n\nui &lt;- dashboardPage(\n  \n      dashboardHeader(title = \"Example App\"),\n      \n      dashboardSidebar(),\n      \n      dashboardBody()\n)\n\n\n\n\nSettings box\nBefore we create any content from our data we need to create a settings box to decide what goes into it. The way different elements in ShinyDashboard work is by putting them in boxes, and then those boxes can be used to populate rows. For example, we can create a box for our settings, and a box for our plots aby updating the dashboardBody in ui.R as follows:\n\nui &lt;- dashboardPage(\n  \n      dashboardHeader(title = \"Example App\"),\n      \n      dashboardSidebar(),\n      \n      dashboardBody(\n        \n        #plot box (we will leave this empty for now)\n        \n        box(\n          width = 9, \n          title = \"Plots\"\n        ), \n        \n        #settings box\n        \n        box(\n          width = 3, #so our plot box is bigger\n          title = \"Settings\"\n        )\n      )\n)\n\nrandom tip: i would STRONGLY reccomend using rainbow parentheses in coding this kind of thing. It essentially makes corresponding open and close brackets mactch colours. Its enabled in Global Options -&gt; Code -&gt; Display. It is also good to use an RStudio theme with good parenthesis highlighting too!\nYou can now see that we have empty plot and settings boxes.\n\nTime to fill them!\nthe possibilities here are endless. You could add a single menu that allows users to select from predefined plots or tables. Or you could have an incredibly complex system that generates complicated plots on demand. We will do something in the middle. We will create a system that allows users to select what they want on the X and Y axes, and then generate the plots for them.\nSo we will add simple dropdown menus to select X-Axis and Y-Axis variables for our plots.\nHere is how we add the X-Axis option menu using selectInput in our ui.R file:\n\n#settings box\n        \nbox(\n  width = 3,\n  title = \"Settings\",\n  \n  selectInput(\n    \n    \n    #set the label for this input we will use internally\n    inputId = xaxis, \n    \n    \n    #the display name/title for this dropdown menu\n    label = \"Select X-Axis Variable\", \n    \n    \n     #here we populate the options for our dropdown menu, and give them better display labels\n    choices = list ( \"Trait Anxiety\" = \"trait_anxiety\",   \n                     \"State Anxiety\" = \"state_anxiety\", \n                     \"Exercise (subjective)\" = \"subj_ex\", \n                     \"Exercsie (objective)\" = \"obj_ex\", \n                     \"Age\" = \"age\", \n                     \"Sex\" = \"sex\"\n    )\n    )\n  )\n\nWe can now repeat this for the Y-Axis\n\n#settings box\n        \nbox(\n  width = 3,\n  title = \"Settings\",\n  \n  selectInput(\n    inputId = \"xaxis\",\n    label = \"Select X-Axis Variable\", \n    choices = list ( \"Trait Anxiety\" = \"trait_anxiety\",   \n                     \"State Anxiety\" = \"state_anxiety\", \n                     \"Exercise (subjective)\" = \"subj_ex\", \n                     \"Exercsie (objective)\" = \"obj_ex\", \n                     \"Age\" = \"age\", \n                     \"Sex\" = \"sex\", \n                     \"Country\" = \"country\")\n    ), \n  \n  selectInput(\n    inputId = \"yaxis\",\n    label = \"Select Y-Axis Variable\", \n    choices = list ( \"Trait Anxiety\" = \"trait_anxiety\",   \n                     \"State Anxiety\" = \"state_anxiety\", \n                     \"Exercise (subjective)\" = \"subj_ex\", \n                     \"Exercsie (objective)\" = \"obj_ex\", \n                     \"Age\" = \"age\", \n                     \"Sex\" = \"sex\", \n                     \"Country\" = \"country\")\n    )          \n  \n  \n  )\n\nIf you now hit Run App you should have something that looks like this, with 2 dropdown menus!\n\n\n\nMaking our plots\nNow we have the menu to select our variables we need to generate the relevant plots, and show them!\nThe UI part of this is quite simple. Just as we added input options to our settings box, we can add outputs to our plot box. We do this by just adding one line to our ui.R file.\n\n#plot box\n\nbox(\n  width = 9, \n  title = \"Plots\",\n  plotOutput(\"plot1\")\n)\n\nThis will return “plot1! in the plot box. However we have not yet defined this so we will do that now. This requires us to hop over to our server.R file.\nAs an example we will first imagine that we only have continuous variables as our options. This would make the task quite simple. We would just generate a plot where the data on the x and y axes are defined by our inputs. This is how we create generate outputs in server.R.\nWe take what we have already…\n\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\ndata &lt;- read.csv(\"data.csv\")\n\n\nserver &lt;- function(input, output) {}\n\nand add our output definition into “server”. output$plot1 creates the “plot1” we just added to our plot box in ui.R. renderPlot() renders the plot that is within it.\n\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\ndata &lt;- read.csv(\"data.csv\")\n\n\nserver &lt;- function(input, output) {\n  \noutput$plot1 &lt;- renderPlot()\n  \n}\n\nwe can now create a quick ggplot scatter plot to go in there. We use input$xaxis to tell ggplot to use the variable selected in the ui for xaxis as our xaxis, and input$yaxis to tell do the same for the y axis.\nWe use !!sym to use these string outputs from our inputs as column names.\n\nserver &lt;- function(input, output) {\n  \n  output$plot1 &lt;- renderPlot(\n    ggplot(data, aes(x = !!sym(input$xaxis), y = !!sym(input$yaxis))) +\n      geom_point()\n    )\n}\n\nYou now have a working dashboard! Hit “Run App” and have a look.\n\nWe could also quickly add a quick bit of flavor to our numerical plots by getting it to colour the plot by country (we will make this selectable later on!), and changing the theme. But that us it for aesthetic changes for this blog.\n\nggplot(data, aes(x = !!sym(input$xaxis), y = !!sym(input$yaxis), color = country)) +\n  geom_point() +\n  theme_minimal()\n\n\nAs we can see this plot works well for our numerical variables, but is less useful for our two categorical ones. So we are going to need different plots depending on our variables. This makes things a little more complicated. But fear not, it is easily achievable by making our output$plot1 call a function which tells it which plot to render, instead of rendering a plot directly.\nSo lets create a function that gives us different plots for different variable combinations. Specifically we will have 4 combinations:\nX-axis categorical + Y-axis categorical X-axis categorical + Y-axis numeric X-axis numeric + Y-axis categorical X-axis numeric + Y-axis numeric\nWe will solve this by creating a function that returns different plots for different combinations. Here is the empty function with the arguments(things we put into the function) we are going to need. We will put this function in our server.R file before the server function.\n\nplotFunction &lt;- function(data, xvar, yvar){}\n\nWe now add a series of if else statements to do our different plots\n\nplotFunction &lt;- function(data, xvar, yvar) {\n  \n  #here we say that if xvar amd yvar are both factors (categorical), then run the plot code in the squiggly brakets\n  \n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    #plot script here\n    \n  }\n  \n}\n\nOne way to plot two categorical variables is using a stacked bar chart, we will do that here as a somewhat hacky (it doesnt really use one variable as the y axis) example:\n\nplotFunction &lt;- function(data, xvar, yvar) {\n  \n#here we say that if xvar amd yvar are both factors (categorical), then run the plot code in the squiggly brackets\n  \n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    ggplot(data,\n           aes(x = xvar,\n               fill = yvar)) +\n      geom_bar(position = \"stack\")\n    \n    \n    #Here we specify that if they are not, use our original plot (with the variables replaced to match those in our function)\n    \n  } else {\n    ggplot(data, aes(x = xvar, y = xvar +\n                       geom_point()))\n  }\n  \n}\n\nOk we now have a simple function that can give us some different plots. Before we go further we should test it. To do this we first have to tell our server to use this function. We do this by updating output$plot1:\n\n#here we specify that output plot1 (which is what we put in our box on our dashboard) should plot whatever comes out of the plotFunction function when we input xaxis (from our ui) as \"xvar\", and yaxis (from our ui) as \"yvar\"\n\noutput$plot1 &lt;- renderPlot(plotFunction(\n  data = data,\n  xvar = !!!sym(input$xaxis),\n  yvar = !!sym(input$yaxis)\n))\n\nSo. server.Rshould look something like this now:\n\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(tidyverse)\n\n\ndata &lt;- read.csv(\"data.csv\")\n\n#### Plot function ####\n\n\nplotFunction &lt;- function(data, xvar, yvar) {\n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    ggplot(data,\n           aes(x = !!sym(xvar),\n               fill = !!sym(yvar))) +\n      geom_bar(position = \"stack\")\n    \n  } else {\n    ggplot(data, aes(\n      x = !!sym(xvar),\n      y = !!sym(yvar),\n      color = country\n    )) +\n      geom_point() +\n      theme_minimal()\n  }\n  \n}\n\n\n#### Server ####\n\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot(plotFunction(\n    data = data,\n    xvar = input$xaxis,\n    yvar = input$yaxis\n  ))\n}\n\nGo ahead and test it out! It should look like this:\n\n\nWe can now go ahead and finish specifying our different plots. For plots where we have a categorical and a numerical variable we could use boxplots:\n\nggplot(data, aes(x = !!sym(xvar),\n                 y = !!sym(yvar),\n                 color = !!sym(xvar))) +\n  \n  geom_boxplot(position = \"dodge\",\n               scale = 0.75,\n               width = 0.12)\n\nWe can now add this to our function:\n\nplotFunction &lt;- function(data, xvar, yvar) {\n  if (is.factor(data[[xvar]]) && is.factor(data[[yvar]])) {\n    ggplot(data,\n           aes(x = !!sym(xvar),\n               fill = !!sym(yvar))) +\n      geom_bar(position = \"stack\") +\n      theme_minimal()\n    \n#we update the else to be an else if, saying that if x is a factor and y is numeric then run this plot\n    \n    } else if (is.factor(data[[xvar]]) && is.numeric(data[[yvar]])) {\n      \n    ggplot(data, aes(x = !!sym(xvar),\n                 y = !!sym(yvar), \n                 color = !!sym(xvar))) +\n        geom_boxplot(position = \"dodge\",\n               scale = 0.75,\n               width = 0.12) +\n        theme_minimal()\n      \n# now we do that the other way around\n      \n      \n    } else if (is.factor(data[[yvar]]) && is.numeric(data[[xvar]])) {\n      \n      ggplot(data, aes(x = !!sym(yvar),\n                       y = !!sym(xvar), \n                       color = !!sym(yvar))) +\n        geom_boxplot(position = \"dodge\",\n                     scale = 0.75,\n                     width = 0.12) +\n        theme_minimal()\n      \n# we now just say if it was none of the above run our original scatter plot\n      \n    } else {\n    ggplot(data, aes(x = !!sym(xvar),\n                     y = !!sym(yvar),\n                     color = country)) +\n      geom_point() +\n      theme_minimal()\n  }\n  \n}\n\n\nSo there you have it. A working dashboard, albeit a simple one. Below here I will go over a couple of extra features, but what we have done above should be a pretty good start to start looking at your data.\n\n\n\nThe sidebar\nWe didn’t speak about the sidebar really, but it is especially useful if you want multiple elements for your dashboard. For example you could have different pages for plots and tables, or you could have different pages for different datasets. We will create a super quick example of the latter here.\nImagine someone else ran the same study and you have their data in a second dataset called dataset 2. We might decide we want separate dashboard pages for both of these. We can create this using the sidebar.\nThis only requires a few tweaks to our ui.R code. All we need to do is put the boxes that currently exist inside our dashboardBody, inside a tabItem, too, and add those to the sidebar.\nFirst lets add two different pages to our sidebar. Allwe have to do to do this is add the following within dashboardSidebar() in our ui.R file:\n\ndashboardSidebar(\n  sidebarMenu(\n    menuItem(\"Dataset 1\",\n             tabName = \"data1\",\n             startExpanded = TRUE),\n    menuItem(\"Dataset 2\",\n         tabName = \"data2\",\n         startExpanded = TRUE),\n)\n)\n\nThis adds two tabs to our sidebar, but right now they don’t do anything.\n To make these tabs different we need to specify different elements in our dashboardBody. We do this by nesting our boxes that we made inside tabItems. So this is what it would look like if have our original boxes, and duplicate these for Dataset 2.\nThe only difference between our two tabItem elements are the name, and I have updated the plot in tab item 2 to be “plot2” instead of “plot 1”. It is important to note that IDs must be unique in shiny apps, so we have also update xaxis and yaxis to be xaxis2 and yaxis2.\n\n    dashboardBody(\n    tabItems(\n      tabItem(\n        tabName = \"data1\",\n      \n      #plot box\n      \n        box(width = 9,\n            title = \"Plots\",\n            plotOutput(\"plot1\")),\n        \n        #settings box\n        \n        box(\n          width = 3,\n          title = \"Settings\",\n          \n          selectInput(\n            inputId = \"xaxis\",\n            label = \"Select X-Axis Variable\",\n            choices = list (\n              \"Trait Anxiety\" = \"trait_anxiety\",\n              \"State Anxiety\" = \"state_anxiety\",\n              \"Exercise (subjective)\" = \"subj_ex\",\n              \"Exercsie (objective)\" = \"obj_ex\",\n              \"Age\" = \"age\",\n              \"Sex\" = \"sex\",\n              \"Country\" = \"country\"\n            )\n          ),\n        \n         selectInput(\n           inputId = \"yaxis\",\n           label = \"Select Y-Axis Variable\",\n           choices = list (\n             \"Trait Anxiety\" = \"trait_anxiety\",\n             \"State Anxiety\" = \"state_anxiety\",\n             \"Exercise (subjective)\" = \"subj_ex\",\n             \"Exercsie (objective)\" = \"obj_ex\",\n             \"Age\" = \"age\",\n             \"Sex\" = \"sex\",\n             \"Country\" = \"country\"\n          )\n        )\n      )\n    ),\n    \n    #tab2  - this is just the same as above with the tweaks to the tabname, inputIds and plotOutputs\n    \n    tabItem(\n      tabName = \"data2\",\n      \n      #plot box (we will leave this empty for now)\n      \n      box(width = 9,\n          title = \"Plots\",\n          plotOutput(\"plot2\")),\n      \n      #settings box\n      \n      box(\n        width = 3,\n        title = \"Settings\",\n        \n        selectInput(\n          inputId = \"xaxis2\",\n          label = \"Select X-Axis Variable\",\n          choices = list (\n            \"Trait Anxiety\" = \"trait_anxiety\",\n            \"State Anxiety\" = \"state_anxiety\",\n            \"Exercise (subjective)\" = \"subj_ex\",\n            \"Exercsie (objective)\" = \"obj_ex\",\n            \"Age\" = \"age\",\n            \"Sex\" = \"sex\",\n            \"Country\" = \"country\"\n          )\n        ),\n        \n        selectInput(\n          inputId = \"yaxis2\",\n          label = \"Select Y-Axis Variable\",\n          choices = list (\n            \"Trait Anxiety\" = \"trait_anxiety\",\n            \"State Anxiety\" = \"state_anxiety\",\n            \"Exercise (subjective)\" = \"subj_ex\",\n            \"Exercsie (objective)\" = \"obj_ex\",\n            \"Age\" = \"age\",\n            \"Sex\" = \"sex\",\n            \"Country\" = \"country\"\n          )\n        )\n      )\n    )\n    \n    \n  ))\n\nThis would now give us two separate pages for our separate datasets. But as you can see there is nothing in the second tab. To get this (and to show that they are different) we can quickly create a second dataset.For llustration we will make this just be the first -1 or 2 for numerical values.\nWe’ll run this in our server file to give us this extra dataset.\n\ndata2 &lt;- data\n\ndata2$age &lt;- data2$age -1\ndata2$trait_anxiety &lt;- data2$trait_anxiety-1\ndata2$state_anxiety &lt;- data2$state_anxiety -2\ndata2$subjective_exercise &lt;- data2$subjective_exercise -1\ndata2$objective_exercise &lt;- data2$objective_exercise -2\n\nWe now van just specify the plot output for this new dataset in server.R. We can still use our original plot function as the data structure is the same:\n\nserver &lt;- function(input, output) {\n  \n  \n  output$plot1 &lt;- renderPlot(plotFunction(\n    data = data,\n    xvar = input$xaxis,\n    yvar = input$yaxis\n  ))\n  \n  #we just duplicate that making the changes to the output and input IDs, and selecting our new data\n  \n    output$plot2 &lt;- renderPlot(plotFunction(\n    data = data2,\n    xvar = input$xaxis2,\n    yvar = input$yaxis2\n  ))\n  \n  \n}\n\nIf you run this now you can see that whilst the data pattern is the same, we can see the axes are different, showing we are plotting our new data!\n\nAnd that is how you make extra tabs :)\n\n\n\nFilters"
  }
]